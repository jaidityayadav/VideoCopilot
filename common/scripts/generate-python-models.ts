#!/usr/bin/env tsx

import fs from 'fs';
import path from 'path';

console.log('üêç Generating Python Pydantic models from Prisma schema...');

// Get current directory
const __dirname = path.dirname(new URL(import.meta.url).pathname);

// Read the Prisma schema
const schemaPath = path.join(__dirname, '../schema/schema.prisma');
const schemaContent = fs.readFileSync(schemaPath, 'utf8');

interface GeneratedModels {
  models: string[];
  enums: string[];
}

// Parse schema and generate Python models
function generatePythonModels(schema: string): GeneratedModels {
  const models: string[] = [];
  const enums: string[] = [];

  // Extract enums
  const enumMatches = schema.match(/enum\s+(\w+)\s*{([^}]+)}/g);
  if (enumMatches) {
    enumMatches.forEach((enumMatch: string) => {
      const enumNameMatch = enumMatch.match(/enum\s+(\w+)/);
      const enumBodyMatch = enumMatch.match(/{([^}]+)}/);

      if (enumNameMatch && enumBodyMatch) {
        const enumName = enumNameMatch[1];
        const enumValues = enumBodyMatch[1]
          .split('\n')
          .map((line: string) => line.trim())
          .filter((line: string) => line && !line.startsWith('//'))
          .map((value: string) => `    ${value} = "${value}"`);

        enums.push(`
class ${enumName}(str, Enum):
${enumValues.join('\n')}
`);
      }
    });
  }

  // Extract models
  const modelMatches = schema.match(/model\s+(\w+)\s*{([^}]+)}/g);
  if (modelMatches) {
    modelMatches.forEach((modelMatch: string) => {
      const modelNameMatch = modelMatch.match(/model\s+(\w+)/);
      const modelFieldsMatch = modelMatch.match(/{([^}]+)}/);

      if (modelNameMatch && modelFieldsMatch) {
        const modelName = modelNameMatch[1];
        const modelFields = modelFieldsMatch[1];

        const fields: string[] = [];
        const lines = modelFields.split('\n')
          .map((line: string) => line.trim())
          .filter((line: string) => line && !line.startsWith('//') && !line.includes('@@') && !line.includes('@relation'));

        lines.forEach((line: string) => {
          const fieldMatch = line.match(/(\w+)\s+(\w+)(\??)\s*(@\w+.*)?/);
          if (fieldMatch) {
            const [, fieldName, fieldType, optional] = fieldMatch;
            let pythonType = mapPrismaTypeToPython(fieldType);

            if (optional === '?') {
              pythonType = `Optional[${pythonType}]`;
            }

            // Handle default values
            let defaultValue = '';
            if (line.includes('@default(')) {
              const defaultMatch = line.match(/@default\(([^)]+)\)/);
              if (defaultMatch) {
                const defaultVal = defaultMatch[1];
                if (defaultVal === 'now()') {
                  defaultValue = ' = Field(default_factory=datetime.now)';
                } else if (defaultVal === 'cuid()') {
                  defaultValue = ' = Field(default_factory=lambda: cuid())';
                } else if (defaultVal.match(/^\d+$/)) {
                  defaultValue = ` = ${defaultVal}`;
                } else if (enums.some((e: string) => e.includes(defaultVal))) {
                  defaultValue = ` = ${fieldType}.${defaultVal}`;
                }
              }
            } else if (optional === '?') {
              defaultValue = ' = None';
            }

            fields.push(`    ${fieldName}: ${pythonType}${defaultValue}`);
          }
        });

        models.push(`
class ${modelName}(BaseModel):
${fields.join('\n')}
    
    class Config:
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat() if v else None
        }
`);
      }
    });
  }

  return { models, enums };
}

function mapPrismaTypeToPython(prismaType: string): string {
  const typeMap: Record<string, string> = {
    'String': 'str',
    'Int': 'int',
    'Float': 'float',
    'Boolean': 'bool',
    'DateTime': 'datetime',
    'Json': 'dict',
    // Custom enums will be handled separately
    'Status': 'Status',
    'VideoStatus': 'VideoStatus'
  };

  return typeMap[prismaType] || prismaType;
}

try {
  const { models, enums } = generatePythonModels(schemaContent);

  const pythonContent = `
"""
Generated Pydantic models from Prisma schema
This file is automatically generated - do not edit manually
Generated at: ${new Date().toISOString()}
"""

from datetime import datetime
from enum import Enum
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field

# You'll need to implement cuid() function or use uuid4
def cuid():
    import uuid
    return str(uuid.uuid4())

${enums.join('\n')}

${models.join('\n')}

# Export all models
__all__ = [
    "User",
    "Project", 
    "Video",
    "Transcript",
    "Embedding",
    "Status",
    "VideoStatus"
]
`.trim();

  const outputPath = path.join(__dirname, '../generated/python/models.py');
  fs.writeFileSync(outputPath, pythonContent);

  // Create __init__.py for Python package
  const initContent = `
"""
VideoCopilot shared models
"""

from .models import *

__version__ = "1.0.0"
`.trim();

  fs.writeFileSync(path.join(__dirname, '../generated/python/__init__.py'), initContent);

  console.log('‚úÖ Python Pydantic models generated successfully!');
  console.log('üìÅ Output location: generated/python/models.py');

} catch (error) {
  console.error('‚ùå Error generating Python models:', error instanceof Error ? error.message : String(error));
  throw error;
}