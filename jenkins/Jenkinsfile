pipeline {
    agent {
        kubernetes {
            label 'jenkins-agent'
            defaultContainer 'kubectl'
            yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: kubectl
    image: bitnami/kubectl:latest
    command:
    - cat
    tty: true
    volumeMounts:
    - name: kubeconfig
      mountPath: /root/.kube/config
      subPath: config
  - name: docker
    image: docker:dind
    securityContext:
      privileged: true
    volumeMounts:
    - name: docker-sock
      mountPath: /var/run/docker.sock
  volumes:
  - name: kubeconfig
    secret:
      secretName: kubeconfig
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock
      type: Socket
"""
        }
    }
    
    environment {
        DOCKER_REGISTRY = 'ghcr.io/jaidityayadav/VideoCopilot'
        NAMESPACE = 'videocopilot'
        MONITORING_NAMESPACE = 'monitoring'
    }
    
    parameters {
        choice(
            name: 'DEPLOY_TARGET',
            choices: ['all', 'app-only', 'monitoring-only', 'web-app', 'embedding-service', 'intelligence-service', 'video-processing-service'],
            description: 'What to deploy'
        )
        booleanParam(
            name: 'SKIP_HEALTH_CHECKS',
            defaultValue: false,
            description: 'Skip health checks after deployment'
        )
        string(
            name: 'IMAGE_TAG',
            defaultValue: 'latest',
            description: 'Docker image tag to deploy (use commit hash for specific version)'
        )
    }
    
    stages {
        stage('Prepare') {
            steps {
                script {
                    // Get commit hash for reference
                    env.COMMIT_HASH = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                    
                    // Determine image tag to use
                    env.IMAGE_TAG = params.IMAGE_TAG == 'latest' ? env.COMMIT_HASH : params.IMAGE_TAG
                    
                    echo "Deploying images with tag: ${env.IMAGE_TAG}"
                    echo "Current commit: ${env.COMMIT_HASH}"
                    echo "Deploy target: ${params.DEPLOY_TARGET}"
                    
                    // Test kubectl connectivity
                    sh 'kubectl version --client'
                    sh 'kubectl get nodes'
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            parallel {
                stage('Deploy Secrets & ConfigMap') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'app-only'] }
                    }
                    steps {
                        script {
                            echo "Deploying secrets and ConfigMap..."
                            sh """
                                kubectl apply -f k8s/00-namespace-secrets.yaml
                                kubectl get secrets -n ${NAMESPACE}
                                kubectl get configmap -n ${NAMESPACE}
                            """
                        }
                    }
                }
                
                stage('Deploy Web App') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'app-only', 'web-app'] }
                    }
                    steps {
                        script {
                            echo "Deploying Web App..."
                            
                            // Update image tag in the manifest
                            sh """
                                sed -i 's|image: ${DOCKER_REGISTRY}/web-app:.*|image: ${DOCKER_REGISTRY}/web-app:${env.IMAGE_TAG}|g' k8s/05-web-app.yaml
                                kubectl apply -f k8s/05-web-app.yaml
                            """
                            
                            // Wait for rollout
                            sh "kubectl rollout status deployment/web-app -n ${NAMESPACE} --timeout=600s"
                            
                            env.WEB_APP_DEPLOYED = 'true'
                        }
                    }
                }
                
                stage('Deploy Embedding Service') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'app-only', 'embedding-service'] }
                    }
                    steps {
                        script {
                            echo "Deploying Embedding Service..."
                            
                            sh """
                                sed -i 's|image: ${DOCKER_REGISTRY}/embedding-service:.*|image: ${DOCKER_REGISTRY}/embedding-service:${env.IMAGE_TAG}|g' k8s/02-embedding-service.yaml
                                kubectl apply -f k8s/02-embedding-service.yaml
                            """
                            
                            sh "kubectl rollout status deployment/embedding-service -n ${NAMESPACE} --timeout=600s"
                            env.EMBEDDING_SERVICE_DEPLOYED = 'true'
                        }
                    }
                }
                
                stage('Deploy Intelligence Service') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'app-only', 'intelligence-service'] }
                    }
                    steps {
                        script {
                            echo "Deploying Intelligence Service..."
                            
                            sh """
                                sed -i 's|image: ${DOCKER_REGISTRY}/intelligence-service:.*|image: ${DOCKER_REGISTRY}/intelligence-service:${env.IMAGE_TAG}|g' k8s/03-intelligence-service.yaml
                                kubectl apply -f k8s/03-intelligence-service.yaml
                            """
                            
                            sh "kubectl rollout status deployment/intelligence-service -n ${NAMESPACE} --timeout=600s"
                            env.INTELLIGENCE_SERVICE_DEPLOYED = 'true'
                        }
                    }
                }
                
                stage('Deploy Video Processing Service') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'app-only', 'video-processing-service'] }
                    }
                    steps {
                        script {
                            echo "Deploying Video Processing Service..."
                            
                            sh """
                                sed -i 's|image: ${DOCKER_REGISTRY}/video-processing-service:.*|image: ${DOCKER_REGISTRY}/video-processing-service:${env.IMAGE_TAG}|g' k8s/04-video-processing-service.yaml
                                kubectl apply -f k8s/04-video-processing-service.yaml
                            """
                            
                            sh "kubectl rollout status deployment/video-processing-service -n ${NAMESPACE} --timeout=600s"
                            env.VIDEO_PROCESSING_SERVICE_DEPLOYED = 'true'
                        }
                    }
                }
                
                stage('Deploy Monitoring') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'monitoring-only'] }
                    }
                    steps {
                        script {
                            echo "Deploying Monitoring Stack (Prometheus + Grafana)..."
                            sh """
                                kubectl apply -f k8s/07-monitoring.yaml
                                
                                echo "Waiting for Prometheus deployment..."
                                kubectl rollout status deployment/prometheus -n ${MONITORING_NAMESPACE} --timeout=300s
                                
                                echo "Waiting for Grafana deployment..."  
                                kubectl rollout status deployment/grafana -n ${MONITORING_NAMESPACE} --timeout=300s
                            """
                            env.MONITORING_DEPLOYED = 'true'
                        }
                    }
                }
                
                stage('Deploy Ingress') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'app-only'] }
                    }
                    steps {
                        script {
                            echo "Deploying Ingress..."
                            sh "kubectl apply -f k8s/06-ingress.yaml"
                        }
                    }
                }
                
                stage('Deploy Jenkins NodePort Service') {
                    when {
                        expression { params.DEPLOY_TARGET in ['all', 'app-only'] }
                    }
                    steps {
                        script {
                            echo "Deploying Jenkins NodePort Service..."
                            sh """
                                kubectl apply -f - <<EOF
apiVersion: v1
kind: Service
metadata:
  name: jenkins-nodeport
  namespace: jenkins
  labels:
    app: jenkins
spec:
  type: NodePort
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    nodePort: 30080
    protocol: TCP
  - name: jnlp
    port: 50000
    targetPort: 50000
    nodePort: 30050
    protocol: TCP
  selector:
    app: jenkins
EOF
                            """
                        }
                    }
                }
            }
        }
        
        stage('Health Checks') {
            when {
                not { params.SKIP_HEALTH_CHECKS }
            }
            steps {
                script {
                    echo "Running health checks..."
                    
                    // Check pod status
                    sh """
                        echo "=== Pod Status ==="
                        kubectl get pods -n ${NAMESPACE} -o wide
                        
                        echo "\\n=== Service Status ==="
                        kubectl get services -n ${NAMESPACE}
                    """
                    
                    // Check individual service health endpoints
                    def services = [
                        'embedding-service': '8001', 
                        'intelligence-service': '8002',
                        'video-processing-service': '8000'
                    ]
                    
                    services.each { serviceName, port ->
                        if (env."${serviceName.toUpperCase().replace('-', '_')}_DEPLOYED" == 'true') {
                            echo "Checking health of ${serviceName}..."
                            sh """
                                kubectl exec -n ${NAMESPACE} deployment/${serviceName} -- curl -f http://localhost:${port}/health || echo "Health check failed for ${serviceName}"
                            """
                        }
                    }
                }
            }
        }
        
        stage('Deployment Summary') {
            steps {
                script {
                    echo "=== DEPLOYMENT SUMMARY ==="
                    echo "Image Tag Used: ${env.IMAGE_TAG}"
                    echo "Commit Hash: ${env.COMMIT_HASH}"
                    echo "Deploy Target: ${params.DEPLOY_TARGET}"
                    
                    // Get service info
                    sh """
                        echo "\\n=== ACCESS URLS ==="
                        echo "Web App: http://143.244.137.118:30000"
                        echo "Prometheus: http://143.244.137.118:30090"
                        echo "Grafana: http://143.244.137.118:31000 (admin/admin123)"
                        echo "Jenkins: http://143.244.137.118:30080"
                    """
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Archive deployment logs
                sh """
                    echo "=== Final Cluster State ===" > deployment-summary.log
                    kubectl get all -n ${NAMESPACE} >> deployment-summary.log 2>&1 || true
                    kubectl get all -n ${MONITORING_NAMESPACE} >> deployment-summary.log 2>&1 || true
                """
                archiveArtifacts artifacts: 'deployment-summary.log', allowEmptyArchive: true
            }
        }
        success {
            echo "ðŸŽ‰ Deployment completed successfully!"
        }
        failure {
            echo "âŒ Deployment failed!"
            script {
                sh """
                    echo "=== Failed Pods Logs ===" > failure-logs.log
                    kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' >> failure-logs.log 2>&1 || true
                """
                archiveArtifacts artifacts: 'failure-logs.log', allowEmptyArchive: true
            }
        }
    }
}